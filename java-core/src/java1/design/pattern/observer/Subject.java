package java1.design.pattern.observer;

/**
 * 抽象主题
 * @author zhaojw
 *  观察者模式：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己
 *
 *  抽象主题（Subject）：他把所有对观察者对象的引用都保存在一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。
 *  具体主题（ConcreteSubject）：将有关状态存入具体观察者对象，在具体主题的内部状态改变时，给所有登记的观察者发出通知。
 *  抽象观察者（Observer）：为所有具体观察者定义一个接口，在得到主题的通知时更新自己，
 *  具体观察者类（WinXinUser）：实现抽象观察者角色所有要求的更新接口，以便使本身的状态与主题的状态相协调。
 *
 *  适用场景：当一个对象的改变时，需要同时改变其他对象。并且，该对象并不知道有多少对象待改变。
 *
 *
 * 由于观察者模式有瑕疵，由于抽象主题依赖抽象观察者，若没有抽象观察者，则观察者模式就不完不成功能。
 * 使用时间委托机制优化。
 * 事件委托：一种引用方法的类型，一旦为委托分配了方法，委托将与该方法具有完全相同的行为，委托方法的使用可以像其他任何方法一样，具有参数和返回值。
 *          委托可以看作是对函数的抽象，是函数的类，委托的实例将代表一个具体的函数。一个委托可以搭载多个方法，所有方法被依次唤起。并且它可以使
 *          搭载的方法并不需要使用同一个类。
 */
public interface Subject {

	/**
     * 增加观察者
     * @param observer
     */
    public void attach(Observer observer);
    /**
     * 删除观察者
     * @param observer
     */
    public void detach(Observer observer);
    /**
     * 通知观察者更新消息，激活
     */
    public void notify(String message);
}
